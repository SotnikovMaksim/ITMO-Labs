package info.kgeorgiy.ja.sotnikov.arrayset;import java.util.*;import java.util.stream.Collectors;public class ArraySet<E> extends AbstractSet<E> implements SortedSet<E> {    /**     * The array buffer into which the elements of the ArrayList are stored.     * The capacity of the ArrayList is the amount of unique elements in input collection. Any     * empty ArraySet has elementData == EMPTY_ELEMENT_DATA.     */    protected List<E> elements;    /**     * If a constructor without comparator is used, usefulComparator == Comparator.naturalOrder().     * In other cases usefulComparator == baseComparator.     */    protected Comparator<? super E> comparator;    /**     * Default empty constructor.     * Comparator == null;     * Elements = EMPTY_ELEMENT_DATA.     */    @SuppressWarnings("unchecked")    public ArraySet() {        this((Comparator<? super E>) Comparator.naturalOrder());    }    /**     * Constructor without initial elements.     *    * Internal comparator equals provided.     * Collection of elements equals EMPTY_ELEMENT_DATA.     * @param comparator user comparator which used for ordering elements.     */    public ArraySet(Comparator<? super E> comparator) {        this(List.of(), comparator);    }    /**     * Constructor which takes only initial elements.     * Natural order will be used for ordering elements.     * @param c collection of initial elements.     */    @SuppressWarnings("unchecked")    public ArraySet(Collection<? extends E> c) {        List<? extends E> sortedList = c == null ? new ArrayList<>() : c.stream().sorted().collect(Collectors.toList());        this.comparator = (Comparator<? super E>) Comparator.naturalOrder();        if (!sortedList.isEmpty()) {            addFrom(sortedList);        } else {            this.elements = List.of();        }    }    /**     * Constructor takes initial elements and comparator for ordering it.     * @param c collection of initial elements.     * @param comparator user comparator which used for ordering elements.     */    public ArraySet(Collection<? extends E> c, Comparator<? super E> comparator) {        List<? extends E> sortedList = (c == null || comparator == null) ? new ArrayList<>() : c.stream().sorted(comparator).collect(Collectors.toList());        this.comparator = comparator;        if (!sortedList.isEmpty()) {            addFrom(sortedList);        } else {            this.elements = List.of();        }    }    /**     * Protected comparator for internal goals.     * Just copying arguments to fields.     * @param elements internal elements     * @param comparator internal comparator     */    protected ArraySet(List<E> elements, Comparator<? super E> comparator) {        this.comparator = comparator;        this.elements = elements;    }    /**     * Common method for constructors that accept non-empty collection of initial elements.     * @param c Sorted collection of initial elements.     */    protected void addFrom(List<? extends E> c) {        List<Integer> indicesOfUnique = new ArrayList<>(List.of(0));        for (int i = 1; i < c.size(); i++) {            if (comparator.compare(c.get(i), c.get(i - 1)) != 0) {                indicesOfUnique.add(i);            }        }        elements = new ArrayList<>(indicesOfUnique.size());        for (Integer i : indicesOfUnique) {            elements.add(c.get(i));        }    }    @Override    public SortedSet<E> headSet(final E toElement) {        int index = floorIndex(toElement);        List<E> subarray = index > -1 ? elements.subList(0, index) : new ArrayList<>();        return new ArraySet<>(subarray, this.comparator);    }    @Override    public SortedSet<E> tailSet(final E fromElement) {        int index = floorIndex(fromElement);        List<E> subarray = (index > -1 && index < elements.size()) ? elements.subList(index, size()) : new ArrayList<>();        return new ArraySet<>(subarray, this.comparator);    }    @Override    public SortedSet<E> subSet(final E fromElement, final E toElement) throws IllegalArgumentException, ClassCastException {        if (comparator.compare(fromElement, toElement) > 0) {            throw new IllegalArgumentException("'fromKey' must bet less or equal than 'toElement'");        }        int rightIndex = floorIndex(toElement);        int leftIndex = floorIndex(fromElement);        List<E> subarray = (leftIndex > -1 && rightIndex > -1) ? elements.subList(leftIndex, rightIndex) : new ArrayList<>();        return new ArraySet<>(subarray, this.comparator);    }    /**     * Private method for searching index of floor value.     * @param e element for which we are looking floor value for     * @return index of element that lower or equal than provided element     */    private int floorIndex(final E e) {        int index = find(e);        return index >= 0 ? index : (index + 1) * -1;    }    @Override    public E first() throws NoSuchElementException {        return elementByIndex(0);    }    @Override    public E last() throws NoSuchElementException {        return elementByIndex(elements.size() - 1);    }    /**     * Common method for first and last methods.     * @param index index of element     * @return element by provided index     * @throws NoSuchElementException if there is no such index in ArrayList     */    protected E elementByIndex(final int index) throws NoSuchElementException {        if (!elements.isEmpty()) {            return elements.get(index);        }        throw new NoSuchElementException("Empty set does not contain any element.");    }    /**     * Searching index of provided element in internal collection.     * Method uses build in binary search algorithm.     * @param e element for which we are looking index for     * @return either index of element if it is exists or -1 * index - 1     */    protected int find(final E e) {        return Collections.binarySearch(elements, e, comparator);    }    @Override    public Iterator<E> iterator() {        return elements.iterator();    }    @Override    @SuppressWarnings("unchecked")    public boolean contains(final Object e) {        return find((E) e) > -1;    }    @Override    public int size() {        return this.elements.size();    }    @Override    public Comparator<? super E> comparator() {        if (comparator.equals(Comparator.naturalOrder())) {            return null;        }        return this.comparator;    }}